## 5 算法讲解

### 5.1 Raft基础

- 典型的Raft集群有5个服务器节点，系统可以最多容忍两个失效
- 领导者：处理全部客户端请求
- 跟随者：完全被动，只响应来自领导者或候选人的请求

跟随者一段时间没有收到消息，自动变成候选人并发起选举。

![](../images/raft-图4.png)

### 5.2 领导人选举

选举发生时，跟随者先增加任期号，接着向其他节点发送RPCs请求给自己投票。发生投票后的三种状态：

- 他自己赢得了这次的选举

若一个候选人赢得选举，就立即成为领导者，立刻向其他服务器发送心跳消息进行通知，同时可以组织其他领导人的产生。

- 其他的服务器成为领导者

等待选票时，收到其他节点的领导人声明，若其任期号不小于候选人当前任期号，则承认其合法，否则拒绝，且保持候选人状态。

- 一段时间之后没有任何一个获胜的人

当多个候选人瓜分选票，导致没有候选人可以获得大多数选票，则增加任期号，开始新一轮选举。没有其他机制的话，选票可能会被无限的重复瓜分。

解决：随机选举超时时间（9.3节展示）

### 5.3 日志复制

#### 提供服务过程

1. 领导人接收到客户端请求，请求中包含需要复制状态机执行的指令


2. 领导人将该指令添加到日志


3. 领导人将该日志条目RPCs发送给其他服务器，让它们复制

领导人需要确保日志所有节点日志相同

![](../images/raft-图6.png)

4. 安全复制后，领导人将该日志条目应用到状态机（提交）

安全复制：大多数跟随者复制了该日志条目

5. 将执行结果返回给客户端

#### 日志不一致

领导人崩溃导致日志不一致：老的领导人可能还没有完全复制所有的日志条目。

![](../images/raft-图7.png)

领导人强制跟随者复制自身日志，解决日志不一致的状态：为每个追随者维护nextIndex，表示下一个需要发送给追随者的日志条目的索引地址。

领导人刚获选时，所有的nextIndex都为自己最后一个日志，在RPC被拒绝时减1，知道相同。

### 5.4 安全性

增加一些限制，以保证领导人拥有之前任期的所有被提交的日志条目。

#### 5.4.1 选举限制

候选人想要赢得选举，必须包含所有已经提交的日志条目。

机制：请投投票RPC中包含了候选人的日志信息，投票人拒绝日志没有自己新的投票请求。

比较方式：两分日志中最后一条日志条目的索引值和任期号。

#### 5.4.2 日志覆盖

新任领导人不考虑原领导人已经复制到部分节点的日志是否被提交，只要和自己不一致就覆盖。一种保守的做法，以确保日志中的条目都是已经被提交的。

简化的问题：并不是所有被提交的条目，都在日志上。

#### 5.4.3 安全性论证

反证法证明

### 5.5 跟随者和候选人崩溃

无限重试

### 5.6 时间和可用性

时间要求：

广播时间（broadcastTime） << 选举超时时间（electionTimeout） << 平均故障间隔时间（MTBF）

