### 3. 系统交互

系统最小化master对各种操作的参与。

#### 3.1 Leases and Mutation Order

mutation就是更改数据块的内容或元数据，比如write或者append操作。每一个mutation需要在所有chunk副本上进行。

通过lease机制来维护一致的mutation操作顺序：先由master选取一个主节点先持有一个lease，在lease内部规定对这个chunk副本的mutation顺序，其它所有副本的修改顺序都与这个主节点保持一致。

例子：
1. client询问master哪一个chunkserver持有chunk的当前lease，以及其它副本位置。如果没有任何chunkserver持有lease，master会选择一个并赋予它lease。
2. master回复持有lease的主节点的身份，以及其它从节点的位置。client缓存下这些数据。只有当在主节点不可访问或者主节点声明自己不再持有lease之后，client才需要再次询问master。
3. client将数据推到所有副本，节点的推送可以以任意顺序进行。此时，每一个chunkserver都只将数据存储在LRU缓存上。（这是实现数据流和控制流的解耦）
4. 当所有的副本都收到数据之后，client告诉primary可以开始写入更改了。
5. primary接着又通知其它所有从节点写入更改。
6. 从节点回复主节点写入完毕
7. 主节点回复client所有节点写入完毕，回复的信息中可能会报错，由client去处理错误信息。

写入可能会超出一个file（chunk）的边界，从而被分为多个不同的操作（会导致一些不一致性？）

#### 3.2 数据流

数据流和控制流解耦后可以更高效地利用网络。

数据的传输采用链式的线性传输方式，可以充分利用每一个机器的带宽【待理解】，并且每一台机器只向距其最近的机器传输。

为了最小化延迟，基于TCP连接进行流水线传输【待理解】

#### 3.3 原子 Record Append

GFS提供的原子性的apend操作就叫做record append。多个client并发地写入时，由于client只负责提供数据，真正地写入操作由GFS来完成，所以能够避免竞争条件。GFS保证来自多个client的数据在每一台机器上的写入顺序都是一样的。

#### 3.4 快照

GFS提供快照机制来快速获取一个文件或目录树的拷贝。基于标准的写时复制技术。

### 4. master的操作

#### 4.1 命名空间和锁

某些操作，比如快照化的时间比较长，为了不让这些操作耽误其它操作的执行，允许同时激活多个操作。背后要使用命名空间锁来保证正确的顺序。

【未完成啊】

